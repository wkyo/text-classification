# coding: utf-8
import json
import time

from keras.callbacks import Callback
from sklearn.metrics import f1_score, precision_score, recall_score
import numpy as np


class F1Score(Callback):
    """Calculate f1-score, precision-score and recall-score for multi-classfication tasks in the training phase

    TODO: Is it possible to make the callback available on evalution and predict mode ?
    """

    def __init__(self, validation_data, average='macro'):
        # TODO: Is there any way to access validation_data generated by `model.fit` ?
        self.val_data = validation_data
        self.average = average
        super().__init__()

    def __init_f1(self):
        self.val_f1 = []
        self.val_recall = []
        self.val_precision = []

    def __update_f1(self, logs=None):
        logs = logs or {}

        if self.val_data is None:
            return

        y_pred = np.argmax(self.model.predict(
            self.val_data[0]), axis=-1)
        y_true = self.val_data[1]
        if y_true.ndim == 2:
            y_true = np.argmax(y_true, axis=-1)
        f1 = f1_score(y_true, y_pred, average=self.average)
        precision = precision_score(y_true, y_pred, average=self.average)
        recall = precision_score(y_true, y_pred, average=self.average)

        logs['val_f1'] = f1
        logs['val_precision'] = precision
        logs['val_recall'] = precision

        self.val_f1.append(f1)
        self.val_precision.append(precision)
        self.val_recall.append(recall)

    def on_epoch_begin(self, epoch, logs=None):
        self.__init_f1()

    def on_epoch_end(self, epoch, logs=None):
        self.__update_f1(logs)


class HistoryLogger(Callback):
    """Record training history to local json file"""

    def __init__(self, filepath):
        self.filepath = filepath
        super().__init__()

    def on_train_begin(self, logs=None):
        self.history = []

    def on_epoch_begin(self, epoch, logs=None):
        self.history.append({
            'epoch': epoch,
            'start': time.time()
        })

    def on_epoch_end(self, epoch, logs=None):
        logs = logs or {}
        self.history[-1].update(logs)
        self.history[-1]['end'] = time.time()

    def on_train_end(self, logs=None):
        with open(self.filepath, 'wt') as fp:
            json.dump(self.history, fp)
